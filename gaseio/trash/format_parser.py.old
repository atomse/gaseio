import os
import re
# import ast
import glob

from atomse.main import atoms
import numpy as np
import pandas as pd
from io import StringIO
from atomse.io import filetype
from atomse import utils
from atomse.utils import randString, unit_to_Ang

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

from .format_string import format_string




def construct_depth_dict(names, value, root=None):
    names = names.split('/')
    root = root or {}
    ptr = root
    for name in names[:-1]:
        if not name in ptr:
            ptr[name] = {}
        ptr = ptr[name]
    ptr[names[-1]] = value
    return root

def get_depth_dict(root, names):
    names = names.split('/')
    ptr = root
    for name in names:
        if isinstance(ptr, dict):
            if not name in ptr:
                return None
            ptr = ptr[name]
        else:
            ptr = getattr(ptr, name, None)
            if ptr is None:
                return None
    return ptr

def get_filestring_and_format(fileobj, format=None):
    if hasattr(fileobj, 'read'):
        fileobj = fileobj.read()
    elif isinstance(fileobj, str):
        if os.path.exists(fileobj):
            format = format or filetype(fileobj)
            fileobj = open(fileobj).read()
    return fileobj.lstrip(), format

def read(fileobj, format=None, get_dict=False, warning=False):
    fileobj, format = get_filestring_and_format(fileobj, format)
    assert format is not None
    # fileobj = fileobj.strip()
    formats = format_string[format]
    reader_formats, ignorance = formats['reader_formats'], formats['ignorance']
    fileobj = '\n'.join([_.strip() for _ in fileobj.split('\n') if not (len(_) > 0 and _[0] in ignorance)])
    arrays = {}
    for pattern, pattern_property in reader_formats.items():
        key_group, important = pattern_property['groups'], pattern_property['important']
        match = re.match(pattern, fileobj)
        if match is None:
            if important:
                raise ValueError(key_group, 'not match, however important')
            elif warning:
                print(' WARNING: ', key_group, 'not matched', '\n')
            continue
        vals = match.groups()
        for key, val in zip(key_group, vals):
            if not isinstance(key[0], tuple):
                name, _type = key
                if _type is dict:
                    st = pd.read_csv(StringIO(val), header=None)[0].str.split(' ', 1, expand=True)
                    _keys, _values = st[0].tolist(), st[1].tolist()
                    val = dict(zip(_keys, [_.strip() for _ in _values]))
                else:
                    val = _type(val)
                    # arrays[name] = val
                arrays.update(construct_depth_dict(name, val, arrays))
            else:
                st = np.array(pd.read_csv(StringIO(val), sep=r'\s+', header=None))
                for subkey, subtype, idx in key:
                    _val = eval('st[{0}]'.format(idx))
                    if subtype in [int, float]:
                        _val = _val.astype(subtype)
                    else:
                        _val = _val.tolist()
                    # arrays[subkey] = _val
                    arrays.update(construct_depth_dict(subkey, _val, arrays))
    if get_dict:
        return arrays
    if arrays.get('unit', None):
        arrays['positions'] *= utils.unit_to_Ang(arrays['unit'])
        del arrays['unit']
    if arrays.get('numbers', None) is not None:
        symbols = arrays.get('numbers')
    else:
        symbols = ''.join(arrays['symbols'])
    _atoms = atoms.Atoms(symbols=symbols, positions=arrays['positions'])

    if 'calculator' in formats:
        _atoms.calc = getattr(atoms, formats['calculator'])()
    for key, val in arrays.items():
        if key in ['symbols', 'positions']:
            continue
        setattr(_atoms, key, val)
    return _atoms


def writer(atoms, format=None):
    assert format is not None
    _format = format_string[format]['writer_formats']
    _fstring = '''f%r ''' %(_format)
    string = eval(_fstring)
    return string


def get_obj_value(obj, key, dict_sep=' '):
    assert isinstance(key, tuple)
    if not isinstance(key[0], tuple):
        name, _type = key
        val = get_depth_dict(obj, name)
        if val is not None:
            if _type in [int, float]:
                val = _type(val)
            elif _type in [dict]:
                val = '{0}{1}{2}'.format(name, dict_sep, val)
    else:
        arrays = None
        for subkey, subtype, idx in key:
            val = get_depth_dict(obj, subkey)
            if isinstance(val, list):
                val = np.array(val)
            if val.ndim == 1:
                val = val.reshape(-1, 1)
            if arrays is None:
                arrays = val
            else:
                arrays = np.hstack([arrays, val])
        val = pd.DataFrame(arrays).to_string(header=None, index=None)
    return val

def template(atoms, template=None, format=None, print_mode=False):
    if template is None:
        template = glob.glob('{0}/base_format/{1}.*'.format(BASE_DIR, format))[0]
    template, format = get_filestring_and_format(template, format)
    assert format is not None
    reader_formats = format_string[format]['reader_formats']
    for pattern, pattern_property in reader_formats.items():
        key_group, important = pattern_property['groups'], pattern_property['important']
        match = re.match(pattern, template)
        if match is None:
            if important:
                raise ValueError(key_group, 'not match, however important')
            continue
        vals = match.groups()
        # start = match.start()
        newval = None
        for i, (key, val) in enumerate(zip(key_group, vals)):
            start = match.start(i+1)
            newval = get_obj_value(atoms, key)
            if newval is not None:
                # print(start, key, '\n', val, '\n', newval, '\n', template.index(val))
                if val[-1] == '\n' and newval[-1] != '\n':
                    newval += '\n'
                template = template[:start] + template[start:].replace(val, str(newval), 1)
                match = re.match(pattern, template)
        # if newval is not None:
    if not print_mode:
        return template
    print(template)


def get_template(fileobj, format=None):
    format = format or filetype(fileobj)
    assert format is not None
    pass

def test():
    import glob
    for _filetype in format_string:
        filename = glob.glob('{0}/base_format/{1}.*'.format(BASE_DIR, _filetype))[0]
        print('\n', _filetype)
        _dict = reader(filename, format=_filetype, get_dict=True, warning=True)
        print(_dict)
        if _filetype == 'gaussian':
            print(_dict.get('connectivity', None))
        print(reader(filename, format=_filetype, ))
    _atoms = atoms.Atoms('C6H6', positions=np.random.rand(12, 3))
    for _filetype in format_string:
        print('\n\n\n ======= ', _filetype)
        template(_atoms, format=_filetype, print_mode=True)




if __name__ == '__main__':
    test()
